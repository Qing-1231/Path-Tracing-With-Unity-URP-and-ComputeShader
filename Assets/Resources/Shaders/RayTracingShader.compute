#pragma kernel CSMain

#include "./Common.hlsl"
#include "./Ray.hlsl"
#include "./Random.hlsl"
#include "./Interval.hlsl"
#include "./Material.hlsl"
#include "./Hit_Record.hlsl"
#include "./Hittable.hlsl"
#include "./Mesh.hlsl"

RWTexture2D<float4> Result;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;
bool _SkyboxTexisNull;

float2 _PixelOffset;
int _RayBounce;


float4 _DirectionalLight;


bool scatter(material mat, inout ray r, inout hit_record rec, inout float3 attenuation)
{
    if (mat.refraction_index > 0.0)
    {
        // Refract
        attenuation *= float3(1, 1, 1);
        float ri = rec.front_face ? (1.0 / mat.refraction_index) : mat.refraction_index;
        
        float3 unit_direction = normalize(r.direction);
        float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);
        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);
        
        bool cannot_refract = ri * sin_theta > 1.0;
        float3 direction;
        if (cannot_refract || reflectance(cos_theta, ri) > rand())
        {
            direction = reflect(unit_direction, rec.normal);
        }
        else
        {
            direction = refract(unit_direction, rec.normal, ri);
        }
        r.origin = rec.p;
        r.direction = direction;
        return true;
    }
    else if (mat.fuzz < 1.0)
    {
        // Metal
        float3 direction = normalize(reflect(r.direction, rec.normal)) + (mat.fuzz * random_in_unit_sphere());
        r.origin = rec.p;
        r.direction = direction;
        attenuation *= mat.albedo;
        return dot(rec.normal, r.direction) > 0;
    }
    else
    {
        // Lambertian
        r.origin = rec.p;
        r.direction = normalize(rec.normal + random_in_unit_sphere());
        if (near_zero(r.direction))
            r.direction = rec.normal;
        attenuation *= mat.albedo;
    }
    return true;
}

float3 ray_color(ray r, hittable_list world)
{
    float3 color_accumulator = float3(0.0, 0.0, 0.0);
    float3 attenuation = float3(1.0, 1.0, 1.0);
    
    for (int i = 0; i < _RayBounce; i++)
    {
        hit_record rec;
        if (hit(world, r, create_interval(0.001, INFINITY), rec))
        {
            if (scatter(rec.mat, r, rec, attenuation))
            {
                continue;
            }
            else
            {
                break;
            }
        }
        else
        {
            float a = 0.5 * (r.direction.y + 1.0);
            color_accumulator += attenuation * ((1.0 - a) * float3(1.0, 1.0, 1.0) + a * float3(0.3, 0.5, 1.0));
            break; // 
        }
    }
    return color_accumulator;

}



[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    _Pixel = id.xy;
    
    float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);

    ray r = CreateCameraRay(uv);
    
    // Render
    hittable_list world;
    world._spheres = _spheres;
    
    float3 result = ray_color(r, world);
    
    Result[id.xy] = float4(result, 1);
}
